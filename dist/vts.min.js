/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/vts.defaults.js":
/*!*****************************!*\
  !*** ./src/vts.defaults.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\n/**\r\n * Global default configuration for Vts (Validate Then Submit).\r\n * @memberof Vts\r\n * @type {Object}\r\n */\r\nconst vtsDefaults = {\r\n  /**\r\n   * Ajax settings\r\n   */\r\n  ajax: {\r\n    request: {\r\n      'Content-Type': 'multipart/form-data',\r\n    },\r\n    /**\r\n     * Ajax beforeSend callback function\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest object\r\n     */\r\n    beforeSend: (xhr) => {},\r\n\r\n    /**\r\n     * Ajax complete callback function\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest object\r\n     * @param {string} textStatus - The status of the request (\"success\", \"error\", \"timeout\", etc.)\r\n     */\r\n    complete: (xhr, textStatus) => {},\r\n\r\n    /**\r\n     * ajax error\r\n     * @param {object} jqXHR\r\n     * @param {String} textStatus\r\n     * @param {String} errorThrown\r\n     */\r\n    error: (error, raw) => {\r\n      console.table(raw);\r\n      alert(error || raw);\r\n      // const customError = jqXHR.responseJSON;\r\n      // const hasCustomError =\r\n      //   'responseJSON' in jqXHR && 'title' in jqXHR.responseJSON;\r\n      // const html = hasCustomError ? customError.text : errorThrown;\r\n      // let cLog = jqXHR.responseText;\r\n\r\n      // let title = hasCustomError\r\n      //   ? customError.title\r\n      //   : textStatus + ': ' + jqXHR.status;\r\n      // if (jqXHR.status === 0) {\r\n      //   title = cLog = 'Please check your connection.';\r\n      // }\r\n      // const text = title + '\\nClick ok to view more details.' + '\\n' + html;\r\n      // if (confirm(text) == true) {\r\n      //   const newWindow = window.open();\r\n      //   newWindow.document.body.innerHTML = cLog;\r\n      // }\r\n      // console.log(cLog);\r\n    },\r\n    /**\r\n     * ajax success\r\n     * @param {object} data\r\n     * @param {object} response\r\n     */\r\n    success: (data, response) => {\r\n      alert(data.title + ':\\n' + data.text);\r\n    },\r\n  },\r\n  /**\r\n   * the classes to be applied on the validated field\r\n   */\r\n  class: {\r\n    /**\r\n     * @type {String}\r\n     */\r\n    valid: 'valid',\r\n    /**\r\n     * @type {String}\r\n     */\r\n    invalid: 'invalid',\r\n  },\r\n  /**\r\n   * Stops the form's submission.\r\n   * @type {Boolean}\r\n   */\r\n  halt: false,\r\n  /**\r\n   * A function to be called if the field is invalid.\r\n   * @param {HTMLElement} currentField\r\n   * @param {String} label\r\n   */\r\n  fnInvalid: (currentField, label, title, message) => {\r\n    currentField.focus();\r\n    currentField.style.border = '1px solid red';\r\n    alert(title + '\\n' + message);\r\n  },\r\n  log: false,\r\n  /**\r\n   * The validation mode.\r\n   * The \"each\" mode will stop the validation if the current field is invalid.\r\n   * The \"all\" mode will continue the validation until all fields have been checked.\r\n   * Fields are validated in the same order as their DOM declaration.\r\n   * @type {String}\r\n   * @default 'each'\r\n   */\r\n  mode: 'each',\r\n  /**\r\n   * regular expressions\r\n   * @type {Object}\r\n   */\r\n  rules: {},\r\n\r\n  /**\r\n   * A function to be called if the field is invalid.\r\n   * @param {HTMLElement} currentField\r\n   * @param {String} label\r\n   */\r\n  fnValid: function (currentField) {\r\n    currentField.style.border = '1px solid green';\r\n  },\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (vtsDefaults);\r\n\n\n//# sourceURL=webpack:///./src/vts.defaults.js?");

/***/ }),

/***/ "./src/vts.js":
/*!********************!*\
  !*** ./src/vts.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vts)\n/* harmony export */ });\n/* harmony import */ var _vts_defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vts.defaults.js */ \"./src/vts.defaults.js\");\n\r\n\r\n/**\r\n * @description A JavaScript library that provides a simple and flexible way to handle\r\n * form validation before submitting. It allows you to customize the validation rules,\r\n * error messages, and actions to be performed when a form field is valid or invalid.\r\n * @author RED\r\n * @class Vts\r\n */\r\nclass Vts {\r\n  /**\r\n   * Creates an instance of Vts.\r\n   * @param {String} formId - The ID of the form to be validated\r\n   * @param {object} [config] optional configuration\r\n   * @memberof Vts\r\n   */\r\n  constructor(formId, config = {}) {\r\n    /** @type {HTMLFormElement} */\r\n    const form = document.getElementById(formId);\r\n\r\n    this.form = form;\r\n    this.formData = new FormData();\r\n    this.fields = form.querySelectorAll('[name]:not([data-vts-ignored])');\r\n    /** @type {Object} */\r\n    this.config = this.#deepMerge({}, _vts_defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], config);\r\n\r\n    this.log && console.group('vts_logs');\r\n    this.log && console.time('vts_exec_time');\r\n    this.#log('log', this);\r\n\r\n    if (form) this.#validate();\r\n    else console.error('Invalid form element.');\r\n  }\r\n\r\n  /**\r\n   * @description Validates each field in the form.\r\n   * @memberof Vts\r\n   */\r\n  #validate() {\r\n    this.#log('info', 'Validation started');\r\n    const config = this.config;\r\n\r\n    const configClass = config.class;\r\n    for (const field of this.fields) {\r\n      this.currentField = field;\r\n      this.#log('log', 'validating:', field);\r\n\r\n      const rule = this.#hasRule();\r\n      let fnInvalidTitle = 'Invalid ' + this.#getLabel();\r\n      let fnInvalidMessage = field.validationMessage;\r\n\r\n      if (rule) {\r\n        const newMessage = this.#applyRule();\r\n        fnInvalidTitle = rule.title || fnInvalidTitle;\r\n        fnInvalidMessage = newMessage || fnInvalidMessage;\r\n      }\r\n\r\n      if (field.checkValidity()) {\r\n        field.classList.remove(configClass.invalid);\r\n        field.classList.add(configClass.valid);\r\n\r\n        if (config.mode === 'each') {\r\n          this.#log('success', 'calling the \"valid\" function...');\r\n          config.fnValid(field, this.#getLabel());\r\n        }\r\n\r\n        if (this.type === 'file') this.#appendFile();\r\n        else this.formData.append(field.name, field.value);\r\n      } else {\r\n        field.classList.remove(configClass.valid);\r\n        field.classList.add(configClass.invalid);\r\n        if (config.mode === 'each') {\r\n          this.#log('warn', 'calling the \"invalid\" function...');\r\n          config.fnInvalid(\r\n            field,\r\n            this.#getLabel(),\r\n            fnInvalidTitle,\r\n            fnInvalidMessage\r\n          );\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (config.mode === 'all') {\r\n      this.#log('success', 'calling the \"valid\" function...');\r\n      config.fnValid(\r\n        this.form.querySelectorAll('.' + configClass.valid),\r\n        this.form\r\n      );\r\n\r\n      this.#log('warn', 'calling the \"invalid\" function...');\r\n      config.fnInvalid(\r\n        this.form.querySelectorAll('.' + configClass.invalid),\r\n        this.form\r\n      );\r\n    }\r\n\r\n    this.#log('info', 'Validation ended');\r\n\r\n    if (!config.halt && this.isValid()) this.submit();\r\n  }\r\n\r\n  /**\r\n   * @description Retrieves the label for the specified field.\r\n   * @param {HTMLElement} [field] - The field element.\r\n   * @memberof Vts\r\n   * @returns {string} The field's label.\r\n   */\r\n  #getLabel(field = this.currentField) {\r\n    const data_label = field.dataset.vtsLabel;\r\n    const label_node = this.form.querySelector('label[for=\"' + field.id + '\"]');\r\n    const label_text = label_node ? label_node.textContent : null;\r\n    const placeholder = field.getAttribute('placeholder');\r\n    const label = data_label || label_text || placeholder || '';\r\n    return label;\r\n  }\r\n\r\n  /**\r\n   * @description Appends file input to the FormData object.\r\n   * @memberof Vts\r\n   */\r\n  #appendFile() {\r\n    /** @type {HTMLInputElement} */\r\n    const field = this.currentField;\r\n    if (field.type === 'file') {\r\n      this.#log('info', 'processing file input...');\r\n      const files = field.files;\r\n      for (let i = 0; i < files.length; i++) {\r\n        /** @type {Array} */\r\n        const file_group = field.dataset.vtsFileGroup;\r\n        const file = files[0];\r\n        // Checks the current field if it has the \"data-vts-file-group\"\r\n        if (file_group) this.formData.append(file_group, file);\r\n        else this.formData.append(field.getAttribute('name'), file);\r\n      }\r\n      return true;\r\n    } else return false;\r\n  }\r\n\r\n  /**\r\n   * @description Logs messages to the console.\r\n   * @param {string} type - The type of log (log, info, warn, success, error).\r\n   * @param  {...any} message - The log messages.\r\n   * @memberof Vts\r\n   */\r\n  #log(type, ...message) {\r\n    if (!this.config.log) return;\r\n\r\n    const msg = '%c' + message;\r\n    const style = 'color: #FFFFFF; padding: 5px';\r\n\r\n    switch (type) {\r\n      case 'log':\r\n        console.log(...message);\r\n        break;\r\n      case 'info':\r\n        console.info(msg, 'background: #5DADE2;' + style);\r\n        break;\r\n      case 'success':\r\n        console.info(msg, 'background: #008000;' + style);\r\n        break;\r\n      case 'warn':\r\n        console.info(msg, 'background: #FF8C00;' + style);\r\n        break;\r\n      case 'error':\r\n        console.info(msg, 'background: #FF0000;' + style);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Applies rules to the current field.\r\n   * @memberof Vts\r\n   * @returns {string} The custom validation message.\r\n   */\r\n  #applyRule() {\r\n    const field = this.currentField;\r\n    const rule = this.config.rules[field.name];\r\n    const value = field.value;\r\n    const match = rule.match;\r\n    const pattern = new RegExp(rule.pattern, rule.flags);\r\n    let message = '';\r\n    let valid;\r\n\r\n    // check if field has rule\r\n    if (!rule) return;\r\n    field.setAttribute('pattern', pattern.source);\r\n    if (match) {\r\n      this.#log('log', 'matching to:', match);\r\n      valid = value == this.formData.get(match);\r\n      const srcMatch = this.form.querySelector('[name=\"' + match + '\"]');\r\n      message =\r\n        rule.message ||\r\n        this.#getLabel() + ' did not match ' + this.#getLabel(srcMatch);\r\n    } else {\r\n      this.#log('log', 'processing pattern:', pattern);\r\n      valid = value.match(pattern);\r\n    }\r\n    // set custom validity\r\n    if (valid) field.setCustomValidity('');\r\n    else field.setCustomValidity(message);\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * @description Checks if the current field has a validation rule.\r\n   * @returns {object} The rule object.\r\n   */\r\n  #hasRule() {\r\n    const name = this.currentField.getAttribute('name');\r\n    return _vts_defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rules[name];\r\n  }\r\n\r\n  /**\r\n   * @description Deeply merges multiple objects.\r\n   * @param {Object} target - The target object to merge into.\r\n   * @param {Array} sources - The source objects to merge.\r\n   * @returns {Object} The merged object.\r\n   * @memberof Vts\r\n   */\r\n  #deepMerge(target, ...sources) {\r\n    if (!sources.length) {\r\n      return target;\r\n    }\r\n\r\n    const source = sources.shift();\r\n\r\n    for (const key in source) {\r\n      if (\r\n        typeof source[key] === 'object' &&\r\n        source[key] !== null &&\r\n        !Array.isArray(source[key])\r\n      ) {\r\n        if (\r\n          !target[key] ||\r\n          typeof target[key] !== 'object' ||\r\n          Array.isArray(target[key])\r\n        ) {\r\n          target[key] = {};\r\n        }\r\n\r\n        this.#deepMerge(target[key], source[key]);\r\n      } else {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return this.#deepMerge(target, ...sources);\r\n  }\r\n\r\n  /**\r\n   * Checks the validity of the form.\r\n   * @returns {Boolean} True if the form is valid, false otherwise.\r\n   */\r\n  isValid() {\r\n    return this.form.checkValidity();\r\n  }\r\n\r\n  /**\r\n   * @description Submits the form via fetch API.\r\n   * @returns {Promise} A promise that resolves on success or rejects on failure.\r\n   * @async\r\n   */\r\n  async submit() {\r\n    if (this.isValid()) {\r\n      delete this.currentField;\r\n      const form = this.form;\r\n      const ajax = this.config.ajax;\r\n      const action = ajax.action || form.action;\r\n      const method = ajax.method || form.method;\r\n      const default_request = {\r\n        method: method,\r\n        headers: {\r\n          'Content-Type': 'multipart/form-data',\r\n        },\r\n        body: this.formData,\r\n      };\r\n      const request = this.#deepMerge({}, default_request, ajax.request);\r\n      try {\r\n        ajax.beforeSend();\r\n        const response = await fetch(action, request);\r\n        if (!response.ok) {\r\n          throw new Error(response.statusText);\r\n        }\r\n        const contentType = response.headers.get('content-type');\r\n        if (contentType && contentType.includes('application/json')) {\r\n          const [data, rawResponse] = await Promise.all([\r\n            response.json(),\r\n            response,\r\n          ]);\r\n          ajax.success(data, rawResponse, form);\r\n        } else {\r\n          throw new TypeError('Response is not in JSON format');\r\n        }\r\n      } catch (error) {\r\n        if (error instanceof Response) {\r\n          try {\r\n            const errorData = await error.json();\r\n            ajax.error(errorData, error, form);\r\n          } catch (e) {\r\n            ajax.error(e, error, form);\r\n          }\r\n        } else {\r\n          ajax.error(null, error, form);\r\n        }\r\n      }\r\n      ajax.complete(form);\r\n    } else {\r\n      this.#log('error', 'Submission failed: Invalid form');\r\n      Promise.reject('invalid form').catch(() => {});\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/vts.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/vts.js");
/******/ 	
/******/ })()
;